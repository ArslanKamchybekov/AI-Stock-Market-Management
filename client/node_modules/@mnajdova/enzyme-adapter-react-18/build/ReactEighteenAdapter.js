"use strict";

var _object = _interopRequireDefault(require("object.assign"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _shallow = _interopRequireDefault(require("react-test-renderer/shallow"));

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _checkPropTypes2 = _interopRequireDefault(require("prop-types/checkPropTypes"));

var _has = _interopRequireDefault(require("has"));

var _reactIs = require("react-is");

var _enzyme = require("enzyme");

var _Utils = require("enzyme/build/Utils");

var _enzymeShallowEqual = _interopRequireDefault(require("enzyme-shallow-equal"));

var _enzymeAdapterUtils = require("enzyme-adapter-utils");

var _findCurrentFiberUsingSlowPath = _interopRequireDefault(require("./findCurrentFiberUsingSlowPath"));

var _detectFiberTags = _interopRequireDefault(require("./detectFiberTags"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// Lazily populated if DOM is available.
var FiberTags = null;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;

  while (node != null) {
    array.push(node);
    node = node.sibling;
  }

  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{
    i: 0,
    array: arr
  }];

  while (stack.length) {
    var n = stack.pop();

    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;

      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({
          i: 0,
          array: el
        });
        break;
      }

      result.push(el);
    }
  }

  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function isMemo(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Memo);
}

function isLazy(type) {
  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Lazy);
}

function unmemoType(type) {
  return isMemo(type) ? type.type : type;
}

function transformSuspense(renderedEl, prerenderEl, _ref) {
  var suspenseFallback = _ref.suspenseFallback;

  if (!(0, _reactIs.isSuspense)(renderedEl)) {
    return renderedEl;
  }

  var children = renderedEl.props.children;

  if (suspenseFallback) {
    var fallback = renderedEl.props.fallback;
    children = replaceLazyWithFallback(children, fallback);
  }

  var _renderedEl$type = renderedEl.type,
      propTypes = _renderedEl$type.propTypes,
      defaultProps = _renderedEl$type.defaultProps,
      contextTypes = _renderedEl$type.contextTypes,
      contextType = _renderedEl$type.contextType,
      childContextTypes = _renderedEl$type.childContextTypes;
  var FakeSuspense = (0, _object["default"])(isStateful(prerenderEl.type) ? /*#__PURE__*/function (_prerenderEl$type) {
    _inherits(FakeSuspense, _prerenderEl$type);

    var _super = _createSuper(FakeSuspense);

    function FakeSuspense() {
      _classCallCheck(this, FakeSuspense);

      return _super.apply(this, arguments);
    }

    _createClass(FakeSuspense, [{
      key: "render",
      value: function render() {
        var type = prerenderEl.type,
            props = prerenderEl.props;
        return /*#__PURE__*/_react["default"].createElement(type, _objectSpread(_objectSpread({}, props), this.props), children);
      }
    }]);

    return FakeSuspense;
  }(prerenderEl.type) : function FakeSuspense(props) {
    // eslint-disable-line prefer-arrow-callback
    return /*#__PURE__*/_react["default"].createElement(renderedEl.type, _objectSpread(_objectSpread({}, renderedEl.props), props), children);
  }, {
    propTypes: propTypes,
    defaultProps: defaultProps,
    contextTypes: contextTypes,
    contextType: contextType,
    childContextTypes: childContextTypes
  });
  return /*#__PURE__*/_react["default"].createElement(FakeSuspense, null, children);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;
  var props = {
    children: children,
    containerInfo: containerInfo
  };
  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  } // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps


  var node = (0, _findCurrentFiberUsingSlowPath["default"])(vnode);

  switch (node.tag) {
    case FiberTags.HostRoot:
      return childrenToTree(node.child);

    case FiberTags.HostPortal:
      {
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;
        var props = {
          containerInfo: containerInfo,
          children: children
        };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case FiberTags.FunctionalComponent:
      return {
        nodeType: 'function',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };

    case FiberTags.MemoClass:
      return {
        nodeType: 'class',
        type: node.elementType.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child.child)
      };

    case FiberTags.MemoSFC:
      {
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'function',
          type: node.elementType,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: renderedNodes
        };
      }

    case FiberTags.HostComponent:
      {
        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (_renderedNodes.length === 0) {
          _renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'host',
          type: node.type,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: _renderedNodes
        };
      }

    case FiberTags.HostText:
      return node.memoizedProps;

    case FiberTags.Fragment:
    case FiberTags.Mode:
    case FiberTags.ContextProvider:
    case FiberTags.ContextConsumer:
      return childrenToTree(node.child);

    case FiberTags.Profiler:
    case FiberTags.ForwardRef:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: _objectSpread({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.Suspense:
      {
        return {
          nodeType: 'function',
          type: _reactIs.Suspense,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case FiberTags.Lazy:
      return childrenToTree(node.child);

    case FiberTags.OffscreenComponent:
      {
        console.log(node["return"].memoizedProps.children);
        return {
          nodeType: 'function',
          type: _reactIs.Suspense,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(_nodeToHostNode(node["return"].memoizedProps.children))
        };
      }

    default:
      throw new Error("Enzyme Internal Error: unknown node with tag ".concat(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }

  var children = nodeAndSiblingsArray(node);

  if (children.length === 0) {
    return null;
  }

  if (children.length === 1) {
    return _toTree(children[0]);
  }

  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;

  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  } // if the SFC returned null effectively, there is no host node.


  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom["default"].findDOMNode(item.instance);
    return null;
  };

  if (Array.isArray(node)) {
    return node.map(mapper);
  }

  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }

  return mapper(node);
}

function replaceLazyWithFallback(node, fallback) {
  if (!node) {
    return null;
  }

  if (Array.isArray(node)) {
    return node.map(function (el) {
      return replaceLazyWithFallback(el, fallback);
    });
  }

  if (isLazy(node.type)) {
    return fallback;
  }

  return _objectSpread(_objectSpread({}, node), {}, {
    props: _objectSpread(_objectSpread({}, node.props), {}, {
      children: replaceLazyWithFallback(node.props.children, fallback)
    })
  });
}

var eventOptions = {
  animation: true,
  pointerEvents: true,
  auxClick: true
};

function wrapAct(fn) {
  var returnVal;

  _testUtils["default"].act(function () {
    returnVal = fn();
  });

  return returnVal;
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }

  if ('_currentValue' in Provider._context) {
    return Provider._context._currentValue;
  }

  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return {
    $$typeof: _reactIs.Element,
    type: type
  };
}

function isStateful(Component) {
  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
  );
}

var ReactEighteenAdapter = /*#__PURE__*/function (_EnzymeAdapter) {
  _inherits(ReactEighteenAdapter, _EnzymeAdapter);

  var _super2 = _createSuper(ReactEighteenAdapter);

  function ReactEighteenAdapter() {
    var _this;

    _classCallCheck(this, ReactEighteenAdapter);

    _this = _super2.call(this);
    var lifecycles = _this.options.lifecycles;
    _this.options = _objectSpread(_objectSpread({}, _this.options), {}, {
      enableComponentDidUpdateOnSetState: true,
      // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: _objectSpread(_objectSpread({}, lifecycles), {}, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: false
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        },
        getDerivedStateFromError: true
      })
    });
    return _this;
  }

  _createClass(ReactEighteenAdapter, [{
    key: "createMountRenderer",
    value: function createMountRenderer(options) {
      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');

      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');
      }

      if (FiberTags === null) {
        // Requires DOM.
        FiberTags = (0, _detectFiberTags["default"])();
      }

      var attachTo = options.attachTo,
          hydrateIn = options.hydrateIn,
          wrappingComponentProps = options.wrappingComponentProps;
      var domNode = hydrateIn || attachTo || global.document.createElement('div');
      var instance = null;
      var adapter = this;
      return {
        render: function render(el, context, callback) {
          return wrapAct(function () {
            if (instance === null) {
              var type = el.type,
                  props = el.props,
                  ref = el.ref;

              var wrapperProps = _objectSpread({
                Component: type,
                props: props,
                wrappingComponentProps: wrappingComponentProps,
                context: context
              }, ref && {
                refProp: ref
              });

              var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread(_objectSpread({}, options), {}, {
                adapter: adapter
              }));

              var wrappedEl = /*#__PURE__*/_react["default"].createElement(ReactWrapperComponent, wrapperProps);

              instance = hydrateIn ? _reactDom["default"].hydrate(wrappedEl, domNode) : _reactDom["default"].render(wrappedEl, domNode);

              if (typeof callback === 'function') {
                callback();
              }
            } else {
              instance.setChildProps(el.props, context, callback);
            }
          });
        },
        unmount: function unmount() {
          _reactDom["default"].unmountComponentAtNode(domNode);

          instance = null;
        },
        getNode: function getNode() {
          if (!instance) {
            return null;
          }

          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternals), options);
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          var isErrorBoundary = function isErrorBoundary(_ref2) {
            var elInstance = _ref2.instance,
                type = _ref2.type;

            if (type && type.getDerivedStateFromError) {
              return true;
            }

            return elInstance && elInstance.componentDidCatch;
          };

          var _ref3 = nodeHierarchy.find(isErrorBoundary) || {},
              catchingInstance = _ref3.instance,
              catchingType = _ref3.type;

          (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, catchingType);
        },
        simulateEvent: function simulateEvent(node, event, mock) {
          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
          var eventFn = _testUtils["default"].Simulate[mappedEvent];

          if (!eventFn) {
            throw new TypeError("ReactWrapper::simulate() event '".concat(event, "' does not exist"));
          }

          wrapAct(function () {
            eventFn(adapter.nodeToHostNode(node), mock);
          });
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        getWrappingComponentRenderer: function getWrappingComponentRenderer() {
          return _objectSpread(_objectSpread({}, this), (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
            toTree: function toTree(inst) {
              return _toTree(inst._reactInternals);
            },
            getMountWrapperInstance: function getMountWrapperInstance() {
              return instance;
            }
          }));
        },
        wrapInvoke: wrapAct
      };
    }
  }, {
    key: "createShallowRenderer",
    value: function createShallowRenderer() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var adapter = this;
      var renderer = new _shallow["default"]();
      var suspenseFallback = options.suspenseFallback;

      if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {
        throw TypeError('`options.suspenseFallback` should be boolean or undefined');
      }

      var isDOM = false;
      var cachedNode = null;
      var lastComponent = null;
      var wrappedComponent = null;
      var sentinel = {}; // wrap memo components with a PureComponent, or a class component with sCU

      var wrapPureComponent = function wrapPureComponent(Component, compare) {
        if (lastComponent !== Component) {
          if (isStateful(Component)) {
            wrappedComponent = /*#__PURE__*/function (_Component) {
              _inherits(wrappedComponent, _Component);

              var _super3 = _createSuper(wrappedComponent);

              function wrappedComponent() {
                _classCallCheck(this, wrappedComponent);

                return _super3.apply(this, arguments);
              }

              return _createClass(wrappedComponent);
            }(Component); // eslint-disable-line react/prefer-stateless-function


            if (compare) {
              wrappedComponent.prototype.shouldComponentUpdate = function (nextProps) {
                return !compare(_this2.props, nextProps);
              };
            } else {
              wrappedComponent.prototype.isPureReactComponent = true;
            }
          } else {
            var memoized = sentinel;
            var prevProps;

            wrappedComponent = function wrappedComponent(props) {
              var shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, _enzymeShallowEqual["default"])(prevProps, props));

              if (shouldUpdate) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                memoized = Component.apply(void 0, [_objectSpread(_objectSpread({}, Component.defaultProps), props)].concat(args));
                prevProps = props;
              }

              return memoized;
            };
          }

          (0, _object["default"])(wrappedComponent, Component, {
            displayName: adapter.displayNameOfNode({
              type: Component
            })
          });
          lastComponent = Component;
        }

        return wrappedComponent;
      };

      var renderElement = function renderElement(elConfig) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }

        var renderedEl = renderer.render.apply(renderer, [elConfig].concat(rest));

        if (renderedEl && renderedEl.type) {
          var clonedEl = transformSuspense(renderedEl, elConfig, {
            suspenseFallback: suspenseFallback
          });
          var elementIsChanged = clonedEl.type !== renderedEl.type;

          if (elementIsChanged) {
            return renderer.render.apply(renderer, [_objectSpread(_objectSpread({}, elConfig), {}, {
              type: clonedEl.type
            })].concat(rest));
          }
        }

        return renderedEl;
      };

      return {
        render: function render(el, unmaskedContext) {
          var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref4$providerValues = _ref4.providerValues,
              providerValues = _ref4$providerValues === void 0 ? new Map() : _ref4$providerValues;

          cachedNode = el;
          /* eslint consistent-return: 0 */

          if (typeof el.type === 'string') {
            isDOM = true;
          } else if ((0, _reactIs.isContextProvider)(el)) {
            providerValues.set(el.type, el.props.value);
            var MockProvider = (0, _object["default"])(function (props) {
              return props.children;
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockProvider
              }));
            });
          } else if ((0, _reactIs.isContextConsumer)(el)) {
            var Provider = adapter.getProviderFromConsumer(el.type);
            var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
            var MockConsumer = (0, _object["default"])(function (props) {
              return props.children(value);
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                type: MockConsumer
              }));
            });
          } else {
            isDOM = false;
            var renderedEl = el;

            if (isLazy(renderedEl)) {
              throw TypeError('`React.lazy` is not supported by shallow rendering.');
            }

            renderedEl = transformSuspense(renderedEl, renderedEl, {
              suspenseFallback: suspenseFallback
            });
            var _renderedEl = renderedEl,
                Component = _renderedEl.type;
            var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

            if (isMemo(el.type)) {
              var _el$type = el.type,
                  InnerComp = _el$type.type,
                  compare = _el$type.compare;
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, el), {}, {
                  type: wrapPureComponent(InnerComp, compare)
                }), context);
              });
            }

            if (!isStateful(Component) && typeof Component === 'function') {
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderElement(_objectSpread(_objectSpread({}, renderedEl), {}, {
                  type: Component
                }), context);
              });
            }

            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderElement(renderedEl, context);
            });
          }
        },
        unmount: function unmount() {
          renderer.unmount();
        },
        getNode: function getNode() {
          if (isDOM) {
            return elementToTree(cachedNode);
          }

          var output = renderer.getRenderOutput();
          return {
            nodeType: nodeTypeFromType(cachedNode.type),
            type: cachedNode.type,
            props: cachedNode.props,
            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
            ref: cachedNode.ref,
            instance: renderer._instance,
            rendered: Array.isArray(output) ? flatten(output).map(function (el) {
              return elementToTree(el);
            }) : elementToTree(output)
          };
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, cachedNode.type);
        },
        simulateEvent: function simulateEvent(node, event) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            args[_key3 - 2] = arguments[_key3];
          }

          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];

          if (handler) {
            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              // TODO(lmr): create/use synthetic events
              // TODO(lmr): emulate React's event propagation
              // ReactDOM.unstable_batchedUpdates(() => {
              handler.apply(void 0, args); // });
            });
          }
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {
          return (0, _checkPropTypes2["default"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
          });
        }
      };
    }
  }, {
    key: "createStringRenderer",
    value: function createStringRenderer(options) {
      if ((0, _has["default"])(options, 'suspenseFallback')) {
        throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');
      }

      return {
        render: function render(el, context) {
          if (options.context && (el.type.contextTypes || options.childContextTypes)) {
            var childContextTypes = _objectSpread(_objectSpread({}, el.type.contextTypes || {}), options.childContextTypes);

            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
            return _server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(ContextWrapper));
          }

          return _server["default"].renderToStaticMarkup(el);
        }
      };
    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "createRenderer",
    value: function createRenderer(options) {
      switch (options.mode) {
        case _enzyme.EnzymeAdapter.MODES.MOUNT:
          return this.createMountRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.SHALLOW:
          return this.createShallowRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.STRING:
          return this.createStringRenderer(options);

        default:
          throw new Error("Enzyme Internal Error: Unrecognized mode: ".concat(options.mode));
      }
    }
  }, {
    key: "wrap",
    value: function wrap(element) {
      return (0, _enzymeAdapterUtils.wrap)(element);
    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "nodeToElement",
    value: function nodeToElement(node) {
      if (!node || _typeof(node) !== 'object') return null;
      var type = node.type;
      return /*#__PURE__*/_react["default"].createElement(unmemoType(type), (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "matchesElementType",
    value: function matchesElementType(node, matchingType) {
      if (!node) {
        return node;
      }

      var type = node.type;
      return unmemoType(type) === unmemoType(matchingType);
    }
  }, {
    key: "elementToNode",
    value: function elementToNode(element) {
      return elementToTree(element);
    }
  }, {
    key: "nodeToHostNode",
    value: function nodeToHostNode(node) {
      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = _nodeToHostNode(node);

      if (Array.isArray(nodes) && !supportsArray) {
        return nodes[0];
      }

      return nodes;
    }
  }, {
    key: "displayNameOfNode",
    value: function displayNameOfNode(node) {
      if (!node) return null;
      var type = node.type,
          $$typeof = node.$$typeof;
      var nodeType = type || $$typeof; // newer node types may be undefined, so only test if the nodeType exists

      if (nodeType) {
        switch (nodeType) {
          case _reactIs.ConcurrentMode || NaN:
            return 'ConcurrentMode';

          case _reactIs.Fragment || NaN:
            return 'Fragment';

          case _reactIs.StrictMode || NaN:
            return 'StrictMode';

          case _reactIs.Profiler || NaN:
            return 'Profiler';

          case _reactIs.Portal || NaN:
            return 'Portal';

          case _reactIs.Suspense || NaN:
            return 'Suspense';

          default:
        }
      }

      var $$typeofType = type && type.$$typeof;

      switch ($$typeofType) {
        case _reactIs.ContextConsumer || NaN:
          return 'ContextConsumer';

        case _reactIs.ContextProvider || NaN:
          return 'ContextProvider';

        case _reactIs.Memo || NaN:
          {
            var nodeName = (0, _enzymeAdapterUtils.displayNameOfNode)(node);
            return typeof nodeName === 'string' ? nodeName : "Memo(".concat((0, _enzymeAdapterUtils.displayNameOfNode)(type), ")");
          }

        case _reactIs.ForwardRef || NaN:
          {
            if (type.displayName) {
              return type.displayName;
            }

            var name = (0, _enzymeAdapterUtils.displayNameOfNode)({
              type: type.render
            });
            return name ? "ForwardRef(".concat(name, ")") : 'ForwardRef';
          }

        case _reactIs.Lazy || NaN:
          {
            return 'lazy';
          }

        default:
          return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
      }
    }
  }, {
    key: "isValidElement",
    value: function isValidElement(element) {
      return (0, _reactIs.isElement)(element);
    }
  }, {
    key: "isValidElementType",
    value: function isValidElementType(object) {
      return !!object && (0, _reactIs.isValidElementType)(object);
    }
  }, {
    key: "isFragment",
    value: function isFragment(fragment) {
      return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
    }
  }, {
    key: "isCustomComponent",
    value: function isCustomComponent(type) {
      var fakeElement = makeFakeElement(type);
      return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement) || (0, _reactIs.isSuspense)(fakeElement));
    }
  }, {
    key: "isContextConsumer",
    value: function isContextConsumer(type) {
      return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
    }
  }, {
    key: "isCustomComponentElement",
    value: function isCustomComponentElement(inst) {
      if (!inst || !this.isValidElement(inst)) {
        return false;
      }

      return this.isCustomComponent(inst.type);
    }
  }, {
    key: "getProviderFromConsumer",
    value: function getProviderFromConsumer(Consumer) {
      // React stores references to the Provider on a Consumer differently across versions.
      if (Consumer) {
        var Provider;

        if (Consumer._context) {
          // check this first, to avoid a deprecation warning
          Provider = Consumer._context.Provider;
        } else if (Consumer.Provider) {
          Provider = Consumer.Provider;
        }

        if (Provider) {
          return Provider;
        }
      }

      throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
    }
  }, {
    key: "createElement",
    value: function createElement() {
      return /*#__PURE__*/_react["default"].createElement.apply(_react["default"], arguments);
    }
  }, {
    key: "wrapWithWrappingComponent",
    value: function wrapWithWrappingComponent(node, options) {
      return {
        RootFinder: _enzymeAdapterUtils.RootFinder,
        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react["default"].createElement, node, options)
      };
    }
  }]);

  return ReactEighteenAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactEighteenAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJGaWJlclRhZ3MiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwidXRpbE5vZGVUeXBlRnJvbVR5cGUiLCJpc01lbW8iLCJjb21wYXJlTm9kZVR5cGVPZiIsIk1lbW8iLCJpc0xhenkiLCJMYXp5IiwidW5tZW1vVHlwZSIsInRyYW5zZm9ybVN1c3BlbnNlIiwicmVuZGVyZWRFbCIsInByZXJlbmRlckVsIiwic3VzcGVuc2VGYWxsYmFjayIsImlzU3VzcGVuc2UiLCJjaGlsZHJlbiIsInByb3BzIiwiZmFsbGJhY2siLCJyZXBsYWNlTGF6eVdpdGhGYWxsYmFjayIsInByb3BUeXBlcyIsImRlZmF1bHRQcm9wcyIsImNvbnRleHRUeXBlcyIsImNvbnRleHRUeXBlIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJGYWtlU3VzcGVuc2UiLCJpc1N0YXRlZnVsIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudFRvVHJlZSIsImlzUG9ydGFsIiwidXRpbEVsZW1lbnRUb1RyZWUiLCJjb250YWluZXJJbmZvIiwibm9kZVR5cGUiLCJrZXkiLCJlbnN1cmVLZXlPclVuZGVmaW5lZCIsInJlZiIsImluc3RhbmNlIiwicmVuZGVyZWQiLCJ0b1RyZWUiLCJ2bm9kZSIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwidGFnIiwiSG9zdFJvb3QiLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwiSG9zdFBvcnRhbCIsInN0YXRlTm9kZSIsIm1lbW9pemVkUHJvcHMiLCJDbGFzc0NvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJNZW1vQ2xhc3MiLCJlbGVtZW50VHlwZSIsIk1lbW9TRkMiLCJyZW5kZXJlZE5vZGVzIiwibWFwIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dFByb3ZpZGVyIiwiQ29udGV4dENvbnN1bWVyIiwiUHJvZmlsZXIiLCJGb3J3YXJkUmVmIiwicGVuZGluZ1Byb3BzIiwiU3VzcGVuc2UiLCJPZmZzY3JlZW5Db21wb25lbnQiLCJjb25zb2xlIiwibG9nIiwibm9kZVRvSG9zdE5vZGUiLCJFcnJvciIsIl9ub2RlIiwibWFwcGVyIiwiaXRlbSIsIlJlYWN0RE9NIiwiZmluZERPTU5vZGUiLCJldmVudE9wdGlvbnMiLCJhbmltYXRpb24iLCJwb2ludGVyRXZlbnRzIiwiYXV4Q2xpY2siLCJ3cmFwQWN0IiwiZm4iLCJyZXR1cm5WYWwiLCJUZXN0VXRpbHMiLCJhY3QiLCJnZXRQcm92aWRlckRlZmF1bHRWYWx1ZSIsIlByb3ZpZGVyIiwiX2NvbnRleHQiLCJfZGVmYXVsdFZhbHVlIiwiX2N1cnJlbnRWYWx1ZSIsIm1ha2VGYWtlRWxlbWVudCIsIiQkdHlwZW9mIiwiRWxlbWVudCIsIkNvbXBvbmVudCIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsIlJlYWN0RWlnaHRlZW5BZGFwdGVyIiwibGlmZWN5Y2xlcyIsIm9wdGlvbnMiLCJlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlIiwibGVnYWN5Q29udGV4dE1vZGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJvblNldFN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJzZXRTdGF0ZSIsInNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImFzc2VydERvbUF2YWlsYWJsZSIsImhhcyIsIlR5cGVFcnJvciIsImRldGVjdEZpYmVyVGFncyIsImF0dGFjaFRvIiwiaHlkcmF0ZUluIiwid3JhcHBpbmdDb21wb25lbnRQcm9wcyIsImRvbU5vZGUiLCJnbG9iYWwiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJyZW5kZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJyZWZQcm9wIiwiUmVhY3RXcmFwcGVyQ29tcG9uZW50IiwiY3JlYXRlTW91bnRXcmFwcGVyIiwid3JhcHBlZEVsIiwiaHlkcmF0ZSIsInNldENoaWxkUHJvcHMiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImdldE5vZGUiLCJnZXROb2RlRnJvbVJvb3RGaW5kZXIiLCJpc0N1c3RvbUNvbXBvbmVudCIsIl9yZWFjdEludGVybmFscyIsInNpbXVsYXRlRXJyb3IiLCJub2RlSGllcmFyY2h5Iiwicm9vdE5vZGUiLCJlcnJvciIsImlzRXJyb3JCb3VuZGFyeSIsImVsSW5zdGFuY2UiLCJjb21wb25lbnREaWRDYXRjaCIsImZpbmQiLCJjYXRjaGluZ0luc3RhbmNlIiwiY2F0Y2hpbmdUeXBlIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJzaW11bGF0ZUV2ZW50IiwiZXZlbnQiLCJtb2NrIiwibWFwcGVkRXZlbnQiLCJtYXBOYXRpdmVFdmVudE5hbWVzIiwiZXZlbnRGbiIsIlNpbXVsYXRlIiwiYmF0Y2hlZFVwZGF0ZXMiLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyIiwiaW5zdCIsImdldE1vdW50V3JhcHBlckluc3RhbmNlIiwid3JhcEludm9rZSIsInJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwiaXNET00iLCJjYWNoZWROb2RlIiwibGFzdENvbXBvbmVudCIsIndyYXBwZWRDb21wb25lbnQiLCJzZW50aW5lbCIsIndyYXBQdXJlQ29tcG9uZW50IiwiY29tcGFyZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRQcm9wcyIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwibWVtb2l6ZWQiLCJwcmV2UHJvcHMiLCJzaG91bGRVcGRhdGUiLCJzaGFsbG93RXF1YWwiLCJhcmdzIiwiZGlzcGxheU5hbWUiLCJyZW5kZXJFbGVtZW50IiwiZWxDb25maWciLCJyZXN0IiwiY2xvbmVkRWwiLCJlbGVtZW50SXNDaGFuZ2VkIiwidW5tYXNrZWRDb250ZXh0IiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJpc0NvbnRleHRQcm92aWRlciIsInNldCIsInZhbHVlIiwiTW9ja1Byb3ZpZGVyIiwid2l0aFNldFN0YXRlQWxsb3dlZCIsImlzQ29udGV4dENvbnN1bWVyIiwiZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIiLCJnZXQiLCJNb2NrQ29uc3VtZXIiLCJnZXRNYXNrZWRDb250ZXh0IiwiSW5uZXJDb21wIiwib3V0cHV0IiwiZ2V0UmVuZGVyT3V0cHV0IiwiX2luc3RhbmNlIiwiY29uY2F0IiwiaGFuZGxlciIsInByb3BGcm9tRXZlbnQiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiaGllcmFyY2h5IiwiZ2V0Q29tcG9uZW50U3RhY2siLCJDb250ZXh0V3JhcHBlciIsImNyZWF0ZVJlbmRlcldyYXBwZXIiLCJSZWFjdERPTVNlcnZlciIsInJlbmRlclRvU3RhdGljTWFya3VwIiwibW9kZSIsIkVuenltZUFkYXB0ZXIiLCJNT0RFUyIsIk1PVU5UIiwiY3JlYXRlTW91bnRSZW5kZXJlciIsIlNIQUxMT1ciLCJjcmVhdGVTaGFsbG93UmVuZGVyZXIiLCJTVFJJTkciLCJjcmVhdGVTdHJpbmdSZW5kZXJlciIsImVsZW1lbnQiLCJ3cmFwIiwicHJvcHNXaXRoS2V5c0FuZFJlZiIsIm1hdGNoaW5nVHlwZSIsInN1cHBvcnRzQXJyYXkiLCJub2RlcyIsIkNvbmN1cnJlbnRNb2RlIiwiTmFOIiwiU3RyaWN0TW9kZSIsIiQkdHlwZW9mVHlwZSIsIm5vZGVOYW1lIiwibmFtZSIsImlzRWxlbWVudCIsIm9iamVjdCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImZyYWdtZW50IiwidHlwZU9mTm9kZSIsImZha2VFbGVtZW50IiwiaXNGb3J3YXJkUmVmIiwiaXNWYWxpZEVsZW1lbnQiLCJDb25zdW1lciIsIlJvb3RGaW5kZXIiLCJ3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdEVpZ2h0ZWVuQWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IDAgKi9cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxyXG5pbXBvcnQgUmVhY3RET01TZXJ2ZXIgZnJvbSAncmVhY3QtZG9tL3NlcnZlcic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxyXG5pbXBvcnQgU2hhbGxvd1JlbmRlcmVyIGZyb20gJ3JlYWN0LXRlc3QtcmVuZGVyZXIvc2hhbGxvdyc7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxyXG5pbXBvcnQgVGVzdFV0aWxzIGZyb20gJ3JlYWN0LWRvbS90ZXN0LXV0aWxzJztcclxuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xyXG5pbXBvcnQgaGFzIGZyb20gJ2hhcyc7XHJcbmltcG9ydCB7XHJcbiAgQ29uY3VycmVudE1vZGUsXHJcbiAgQ29udGV4dENvbnN1bWVyLFxyXG4gIENvbnRleHRQcm92aWRlcixcclxuICBFbGVtZW50LFxyXG4gIEZvcndhcmRSZWYsXHJcbiAgRnJhZ21lbnQsXHJcbiAgaXNDb250ZXh0Q29uc3VtZXIsXHJcbiAgaXNDb250ZXh0UHJvdmlkZXIsXHJcbiAgaXNFbGVtZW50LFxyXG4gIGlzRm9yd2FyZFJlZixcclxuICBpc1BvcnRhbCxcclxuICBpc1N1c3BlbnNlLFxyXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcclxuICBMYXp5LFxyXG4gIE1lbW8sXHJcbiAgUG9ydGFsLFxyXG4gIFByb2ZpbGVyLFxyXG4gIFN0cmljdE1vZGUsXHJcbiAgU3VzcGVuc2UsXHJcbn0gZnJvbSAncmVhY3QtaXMnO1xyXG5pbXBvcnQgeyBFbnp5bWVBZGFwdGVyIH0gZnJvbSAnZW56eW1lJztcclxuaW1wb3J0IHsgdHlwZU9mTm9kZSB9IGZyb20gJ2VuenltZS9idWlsZC9VdGlscyc7XHJcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnZW56eW1lLXNoYWxsb3ctZXF1YWwnO1xyXG5pbXBvcnQge1xyXG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxyXG4gIGVsZW1lbnRUb1RyZWUgYXMgdXRpbEVsZW1lbnRUb1RyZWUsXHJcbiAgbm9kZVR5cGVGcm9tVHlwZSBhcyB1dGlsTm9kZVR5cGVGcm9tVHlwZSxcclxuICBtYXBOYXRpdmVFdmVudE5hbWVzLFxyXG4gIHByb3BGcm9tRXZlbnQsXHJcbiAgYXNzZXJ0RG9tQXZhaWxhYmxlLFxyXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXHJcbiAgY3JlYXRlUmVuZGVyV3JhcHBlcixcclxuICBjcmVhdGVNb3VudFdyYXBwZXIsXHJcbiAgcHJvcHNXaXRoS2V5c0FuZFJlZixcclxuICBlbnN1cmVLZXlPclVuZGVmaW5lZCxcclxuICBzaW11bGF0ZUVycm9yLFxyXG4gIHdyYXAsXHJcbiAgZ2V0TWFza2VkQ29udGV4dCxcclxuICBnZXRDb21wb25lbnRTdGFjayxcclxuICBSb290RmluZGVyLFxyXG4gIGdldE5vZGVGcm9tUm9vdEZpbmRlcixcclxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50LFxyXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcixcclxuICBjb21wYXJlTm9kZVR5cGVPZixcclxufSBmcm9tICdlbnp5bWUtYWRhcHRlci11dGlscyc7XHJcbmltcG9ydCBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCBmcm9tICcuL2ZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoJztcclxuaW1wb3J0IGRldGVjdEZpYmVyVGFncyBmcm9tICcuL2RldGVjdEZpYmVyVGFncyc7XHJcblxyXG4vLyBMYXppbHkgcG9wdWxhdGVkIGlmIERPTSBpcyBhdmFpbGFibGUuXHJcbmxldCBGaWJlclRhZ3MgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZVdpdGhTaWJsaW5nKSB7XHJcbiAgY29uc3QgYXJyYXkgPSBbXTtcclxuICBsZXQgbm9kZSA9IG5vZGVXaXRoU2libGluZztcclxuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XHJcbiAgICBhcnJheS5wdXNoKG5vZGUpO1xyXG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcclxuICB9XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmbGF0dGVuKGFycikge1xyXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gIGNvbnN0IHN0YWNrID0gW3sgaTogMCwgYXJyYXk6IGFyciB9XTtcclxuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XHJcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XHJcbiAgICB3aGlsZSAobi5pIDwgbi5hcnJheS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgZWwgPSBuLmFycmF5W24uaV07XHJcbiAgICAgIG4uaSArPSAxO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcclxuICAgICAgICBzdGFjay5wdXNoKG4pO1xyXG4gICAgICAgIHN0YWNrLnB1c2goeyBpOiAwLCBhcnJheTogZWwgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0LnB1c2goZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2RlVHlwZUZyb21UeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZSA9PT0gUG9ydGFsKSB7XHJcbiAgICByZXR1cm4gJ3BvcnRhbCc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdXRpbE5vZGVUeXBlRnJvbVR5cGUodHlwZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTWVtbyh0eXBlKSB7XHJcbiAgcmV0dXJuIGNvbXBhcmVOb2RlVHlwZU9mKHR5cGUsIE1lbW8pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xhenkodHlwZSkge1xyXG4gIHJldHVybiBjb21wYXJlTm9kZVR5cGVPZih0eXBlLCBMYXp5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5tZW1vVHlwZSh0eXBlKSB7XHJcbiAgcmV0dXJuIGlzTWVtbyh0eXBlKSA/IHR5cGUudHlwZSA6IHR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN1c3BlbnNlKHJlbmRlcmVkRWwsIHByZXJlbmRlckVsLCB7IHN1c3BlbnNlRmFsbGJhY2sgfSkge1xyXG4gIGlmICghaXNTdXNwZW5zZShyZW5kZXJlZEVsKSkge1xyXG4gICAgcmV0dXJuIHJlbmRlcmVkRWw7XHJcbiAgfVxyXG5cclxuICBsZXQgeyBjaGlsZHJlbiB9ID0gcmVuZGVyZWRFbC5wcm9wcztcclxuXHJcbiAgaWYgKHN1c3BlbnNlRmFsbGJhY2spIHtcclxuICAgIGNvbnN0IHsgZmFsbGJhY2sgfSA9IHJlbmRlcmVkRWwucHJvcHM7XHJcbiAgICBjaGlsZHJlbiA9IHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKGNoaWxkcmVuLCBmYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7XHJcbiAgICBwcm9wVHlwZXMsXHJcbiAgICBkZWZhdWx0UHJvcHMsXHJcbiAgICBjb250ZXh0VHlwZXMsXHJcbiAgICBjb250ZXh0VHlwZSxcclxuICAgIGNoaWxkQ29udGV4dFR5cGVzLFxyXG4gIH0gPSByZW5kZXJlZEVsLnR5cGU7XHJcblxyXG4gIGNvbnN0IEZha2VTdXNwZW5zZSA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICBpc1N0YXRlZnVsKHByZXJlbmRlckVsLnR5cGUpXHJcbiAgICAgID8gY2xhc3MgRmFrZVN1c3BlbnNlIGV4dGVuZHMgcHJlcmVuZGVyRWwudHlwZSB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcyB9ID0gcHJlcmVuZGVyRWw7XHJcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgeyAuLi5wcm9wcywgLi4udGhpcy5wcm9wcyB9LFxyXG4gICAgICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIDogZnVuY3Rpb24gRmFrZVN1c3BlbnNlKHByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWFycm93LWNhbGxiYWNrXHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXHJcbiAgICAgICAgICByZW5kZXJlZEVsLnR5cGUsXHJcbiAgICAgICAgICB7IC4uLnJlbmRlcmVkRWwucHJvcHMsIC4uLnByb3BzIH0sXHJcbiAgICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAge1xyXG4gICAgICBwcm9wVHlwZXMsXHJcbiAgICAgIGRlZmF1bHRQcm9wcyxcclxuICAgICAgY29udGV4dFR5cGVzLFxyXG4gICAgICBjb250ZXh0VHlwZSxcclxuICAgICAgY2hpbGRDb250ZXh0VHlwZXMsXHJcbiAgICB9LFxyXG4gICk7XHJcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZVN1c3BlbnNlLCBudWxsLCBjaGlsZHJlbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVsZW1lbnRUb1RyZWUoZWwpIHtcclxuICBpZiAoIWlzUG9ydGFsKGVsKSkge1xyXG4gICAgcmV0dXJuIHV0aWxFbGVtZW50VG9UcmVlKGVsLCBlbGVtZW50VG9UcmVlKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRhaW5lckluZm8gfSA9IGVsO1xyXG4gIGNvbnN0IHByb3BzID0geyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxyXG4gICAgdHlwZTogUG9ydGFsLFxyXG4gICAgcHJvcHMsXHJcbiAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGVsLmtleSksXHJcbiAgICByZWY6IGVsLnJlZiB8fCBudWxsLFxyXG4gICAgaW5zdGFuY2U6IG51bGwsXHJcbiAgICByZW5kZXJlZDogZWxlbWVudFRvVHJlZShlbC5jaGlsZHJlbiksXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9UcmVlKHZub2RlKSB7XHJcbiAgaWYgKHZub2RlID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICAvLyBUT0RPKGxtcik6IEknbSBub3QgcmVhbGx5IHN1cmUgSSB1bmRlcnN0YW5kIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgd2hhdFxyXG4gIC8vIGkgc2hvdWxkIGJlIGRvaW5nLCBvciBpZiB0aGlzIGlzIGEgaGFjayBmb3Igc29tZXRoaW5nIGknbSBkb2luZyB3cm9uZ1xyXG4gIC8vIHNvbWV3aGVyZSBlbHNlLiBTaG91bGQgdGFsayB0byBzZWJhc3RpYW4gYWJvdXQgdGhpcyBwZXJoYXBzXHJcbiAgY29uc3Qgbm9kZSA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHZub2RlKTtcclxuICBzd2l0Y2ggKG5vZGUudGFnKSB7XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0Um9vdDpcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xyXG4gICAgY2FzZSBGaWJlclRhZ3MuSG9zdFBvcnRhbDoge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgc3RhdGVOb2RlOiB7IGNvbnRhaW5lckluZm8gfSxcclxuICAgICAgICBtZW1vaXplZFByb3BzOiBjaGlsZHJlbixcclxuICAgICAgfSA9IG5vZGU7XHJcbiAgICAgIGNvbnN0IHByb3BzID0geyBjb250YWluZXJJbmZvLCBjaGlsZHJlbiB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcclxuICAgICAgICB0eXBlOiBQb3J0YWwsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlIEZpYmVyVGFncy5DbGFzc0NvbXBvbmVudDpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2NsYXNzJyxcclxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXHJcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBGaWJlclRhZ3MuRnVuY3Rpb25hbENvbXBvbmVudDpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIEZpYmVyVGFncy5NZW1vQ2xhc3M6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZVR5cGU6ICdjbGFzcycsXHJcbiAgICAgICAgdHlwZTogbm9kZS5lbGVtZW50VHlwZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxyXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxyXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXHJcbiAgICAgICAgaW5zdGFuY2U6IG5vZGUuc3RhdGVOb2RlLFxyXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkLmNoaWxkKSxcclxuICAgICAgfTtcclxuICAgIGNhc2UgRmliZXJUYWdzLk1lbW9TRkM6IHtcclxuICAgICAgbGV0IHJlbmRlcmVkTm9kZXMgPSBmbGF0dGVuKG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUuY2hpbGQpLm1hcCh0b1RyZWUpKTtcclxuICAgICAgaWYgKHJlbmRlcmVkTm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmVuZGVyZWROb2RlcyA9IFtub2RlLm1lbW9pemVkUHJvcHMuY2hpbGRyZW5dO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXHJcbiAgICAgICAgdHlwZTogbm9kZS5lbGVtZW50VHlwZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSBGaWJlclRhZ3MuSG9zdENvbXBvbmVudDoge1xyXG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xyXG4gICAgICBpZiAocmVuZGVyZWROb2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZW5kZXJlZE5vZGVzID0gW25vZGUubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbl07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2hvc3QnLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcclxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWROb2RlcyxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgRmliZXJUYWdzLkhvc3RUZXh0OlxyXG4gICAgICByZXR1cm4gbm9kZS5tZW1vaXplZFByb3BzO1xyXG4gICAgY2FzZSBGaWJlclRhZ3MuRnJhZ21lbnQ6XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Nb2RlOlxyXG4gICAgY2FzZSBGaWJlclRhZ3MuQ29udGV4dFByb3ZpZGVyOlxyXG4gICAgY2FzZSBGaWJlclRhZ3MuQ29udGV4dENvbnN1bWVyOlxyXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XHJcbiAgICBjYXNlIEZpYmVyVGFncy5Qcm9maWxlcjpcclxuICAgIGNhc2UgRmliZXJUYWdzLkZvcndhcmRSZWY6IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5wZW5kaW5nUHJvcHMgfSxcclxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcclxuICAgICAgICByZWY6IG5vZGUucmVmLFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgRmliZXJUYWdzLlN1c3BlbnNlOiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXHJcbiAgICAgICAgdHlwZTogU3VzcGVuc2UsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlIEZpYmVyVGFncy5MYXp5OlxyXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XHJcbiAgICBjYXNlIEZpYmVyVGFncy5PZmZzY3JlZW5Db21wb25lbnQ6IHtcclxuICAgICAgY29uc29sZS5sb2cobm9kZS5yZXR1cm4ubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZVR5cGU6ICdmdW5jdGlvbicsXHJcbiAgICAgICAgdHlwZTogU3VzcGVuc2UsXHJcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXHJcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXHJcbiAgICAgICAgcmVmOiBub2RlLnJlZixcclxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZVRvSG9zdE5vZGUobm9kZS5yZXR1cm4ubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbikpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IHVua25vd24gbm9kZSB3aXRoIHRhZyAke25vZGUudGFnfWApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hpbGRyZW5Ub1RyZWUobm9kZSkge1xyXG4gIGlmICghbm9kZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZSk7XHJcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgIHJldHVybiB0b1RyZWUoY2hpbGRyZW5bMF0pO1xyXG4gIH1cclxuICByZXR1cm4gZmxhdHRlbihjaGlsZHJlbi5tYXAodG9UcmVlKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vZGVUb0hvc3ROb2RlKF9ub2RlKSB7XHJcbiAgLy8gTk9URShsbXIpOiBub2RlIGNvdWxkIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50XHJcbiAgLy8gd2hpY2ggd29udCBoYXZlIGFuIGluc3RhbmNlIHByb3AsIGJ1dCB3ZSBjYW4gZ2V0IHRoZVxyXG4gIC8vIGhvc3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXRzIHJldHVybiB2YWx1ZSBhdCB0aGF0IHBvaW50LlxyXG4gIC8vIEFsdGhvdWdoIHRoaXMgYnJlYWtzIGRvd24gaWYgdGhlIHJldHVybiB2YWx1ZSBpcyBhbiBhcnJheSxcclxuICAvLyBhcyBpcyBwb3NzaWJsZSB3aXRoIFJlYWN0IDE2LlxyXG4gIGxldCBub2RlID0gX25vZGU7XHJcbiAgd2hpbGUgKG5vZGUgJiYgIUFycmF5LmlzQXJyYXkobm9kZSkgJiYgbm9kZS5pbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgbm9kZSA9IG5vZGUucmVuZGVyZWQ7XHJcbiAgfVxyXG4gIC8vIGlmIHRoZSBTRkMgcmV0dXJuZWQgbnVsbCBlZmZlY3RpdmVseSwgdGhlcmUgaXMgbm8gaG9zdCBub2RlLlxyXG4gIGlmICghbm9kZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBtYXBwZXIgPSAoaXRlbSkgPT4ge1xyXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5pbnN0YW5jZSkgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKGl0ZW0uaW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xyXG4gICAgcmV0dXJuIG5vZGUubWFwKG1hcHBlcik7XHJcbiAgfVxyXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUucmVuZGVyZWQpICYmIG5vZGUubm9kZVR5cGUgPT09ICdjbGFzcycpIHtcclxuICAgIHJldHVybiBub2RlLnJlbmRlcmVkLm1hcChtYXBwZXIpO1xyXG4gIH1cclxuICByZXR1cm4gbWFwcGVyKG5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlTGF6eVdpdGhGYWxsYmFjayhub2RlLCBmYWxsYmFjaykge1xyXG4gIGlmICghbm9kZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICByZXR1cm4gbm9kZS5tYXAoKGVsKSA9PiByZXBsYWNlTGF6eVdpdGhGYWxsYmFjayhlbCwgZmFsbGJhY2spKTtcclxuICB9XHJcbiAgaWYgKGlzTGF6eShub2RlLnR5cGUpKSB7XHJcbiAgICByZXR1cm4gZmFsbGJhY2s7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5ub2RlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgLi4ubm9kZS5wcm9wcyxcclxuICAgICAgY2hpbGRyZW46IHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKG5vZGUucHJvcHMuY2hpbGRyZW4sIGZhbGxiYWNrKSxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG5cclxuY29uc3QgZXZlbnRPcHRpb25zID0ge1xyXG4gIGFuaW1hdGlvbjogdHJ1ZSxcclxuICBwb2ludGVyRXZlbnRzOiB0cnVlLFxyXG4gIGF1eENsaWNrOiB0cnVlLFxyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JhcEFjdChmbikge1xyXG4gIGxldCByZXR1cm5WYWw7XHJcbiAgVGVzdFV0aWxzLmFjdCgoKSA9PiB7IHJldHVyblZhbCA9IGZuKCk7IH0pO1xyXG4gIHJldHVybiByZXR1cm5WYWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKSB7XHJcbiAgLy8gUmVhY3Qgc3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIFByb3ZpZGVyJ3MgZGVmYXVsdFZhbHVlIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cclxuICBpZiAoJ19kZWZhdWx0VmFsdWUnIGluIFByb3ZpZGVyLl9jb250ZXh0KSB7XHJcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2RlZmF1bHRWYWx1ZTtcclxuICB9XHJcbiAgaWYgKCdfY3VycmVudFZhbHVlJyBpbiBQcm92aWRlci5fY29udGV4dCkge1xyXG4gICAgcmV0dXJuIFByb3ZpZGVyLl9jb250ZXh0Ll9jdXJyZW50VmFsdWU7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlcuKAmXMgZGVmYXVsdCB2YWx1ZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlRmFrZUVsZW1lbnQodHlwZSkge1xyXG4gIHJldHVybiB7ICQkdHlwZW9mOiBFbGVtZW50LCB0eXBlIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWwoQ29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgKFxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XHJcbiAgICB8fCBBcnJheS5pc0FycmF5KENvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycykgLy8gZmFsbGJhY2sgZm9yIGNyZWF0ZUNsYXNzIGNvbXBvbmVudHNcclxuICApO1xyXG59XHJcblxyXG5jbGFzcyBSZWFjdEVpZ2h0ZWVuQWRhcHRlciBleHRlbmRzIEVuenltZUFkYXB0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIGNvbnN0IHsgbGlmZWN5Y2xlcyB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAuLi50aGlzLm9wdGlvbnMsXHJcbiAgICAgIGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGU6IHRydWUsIC8vIFRPRE86IHJlbW92ZSwgc2VtdmVyLW1ham9yXHJcbiAgICAgIGxlZ2FjeUNvbnRleHRNb2RlOiAncGFyZW50JyxcclxuICAgICAgbGlmZWN5Y2xlczoge1xyXG4gICAgICAgIC4uLmxpZmVjeWNsZXMsXHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiB7XHJcbiAgICAgICAgICBvblNldFN0YXRlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB7XHJcbiAgICAgICAgICBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWc6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU6IHRydWUsXHJcbiAgICAgICAgc2V0U3RhdGU6IHtcclxuICAgICAgICAgIHNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XHJcbiAgICAgICAgICBjYWxsZWRCeVJlbmRlcmVyOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIGFzc2VydERvbUF2YWlsYWJsZSgnbW91bnQnKTtcclxuICAgIGlmIChoYXMob3B0aW9ucywgJ3N1c3BlbnNlRmFsbGJhY2snKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgc3VzcGVuc2VGYWxsYmFja2AgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYG1vdW50YCByZW5kZXJlcicpO1xyXG4gICAgfVxyXG4gICAgaWYgKEZpYmVyVGFncyA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBSZXF1aXJlcyBET00uXHJcbiAgICAgIEZpYmVyVGFncyA9IGRldGVjdEZpYmVyVGFncygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBhdHRhY2hUbywgaHlkcmF0ZUluLCB3cmFwcGluZ0NvbXBvbmVudFByb3BzIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgZG9tTm9kZSA9IGh5ZHJhdGVJbiB8fCBhdHRhY2hUbyB8fCBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xyXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBBY3QoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHJlZiB9ID0gZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJQcm9wcyA9IHtcclxuICAgICAgICAgICAgICBDb21wb25lbnQ6IHR5cGUsXHJcbiAgICAgICAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgICAgICAgd3JhcHBpbmdDb21wb25lbnRQcm9wcyxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICAgIC4uLihyZWYgJiYgeyByZWZQcm9wOiByZWYgfSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IFJlYWN0V3JhcHBlckNvbXBvbmVudCA9IGNyZWF0ZU1vdW50V3JhcHBlcihlbCwgeyAuLi5vcHRpb25zLCBhZGFwdGVyIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkRWwgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0V3JhcHBlckNvbXBvbmVudCwgd3JhcHBlclByb3BzKTtcclxuICAgICAgICAgICAgaW5zdGFuY2UgPSBoeWRyYXRlSW5cclxuICAgICAgICAgICAgICA/IFJlYWN0RE9NLmh5ZHJhdGUod3JhcHBlZEVsLCBkb21Ob2RlKVxyXG4gICAgICAgICAgICAgIDogUmVhY3RET00ucmVuZGVyKHdyYXBwZWRFbCwgZG9tTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRDaGlsZFByb3BzKGVsLnByb3BzLCBjb250ZXh0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShkb21Ob2RlKTtcclxuICAgICAgICBpbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXROb2RlRnJvbVJvb3RGaW5kZXIoXHJcbiAgICAgICAgICBhZGFwdGVyLmlzQ3VzdG9tQ29tcG9uZW50LFxyXG4gICAgICAgICAgdG9UcmVlKGluc3RhbmNlLl9yZWFjdEludGVybmFscyksXHJcbiAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNpbXVsYXRlRXJyb3Iobm9kZUhpZXJhcmNoeSwgcm9vdE5vZGUsIGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgaXNFcnJvckJvdW5kYXJ5ID0gKHsgaW5zdGFuY2U6IGVsSW5zdGFuY2UsIHR5cGUgfSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZWxJbnN0YW5jZSAmJiBlbEluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIGluc3RhbmNlOiBjYXRjaGluZ0luc3RhbmNlLFxyXG4gICAgICAgICAgdHlwZTogY2F0Y2hpbmdUeXBlLFxyXG4gICAgICAgIH0gPSBub2RlSGllcmFyY2h5LmZpbmQoaXNFcnJvckJvdW5kYXJ5KSB8fCB7fTtcclxuXHJcbiAgICAgICAgc2ltdWxhdGVFcnJvcihcclxuICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgY2F0Y2hpbmdJbnN0YW5jZSxcclxuICAgICAgICAgIHJvb3ROb2RlLFxyXG4gICAgICAgICAgbm9kZUhpZXJhcmNoeSxcclxuICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXHJcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxyXG4gICAgICAgICAgY2F0Y2hpbmdUeXBlLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcclxuICAgICAgICBjb25zdCBtYXBwZWRFdmVudCA9IG1hcE5hdGl2ZUV2ZW50TmFtZXMoZXZlbnQsIGV2ZW50T3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRGbiA9IFRlc3RVdGlscy5TaW11bGF0ZVttYXBwZWRFdmVudF07XHJcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWFjdFdyYXBwZXI6OnNpbXVsYXRlKCkgZXZlbnQgJyR7ZXZlbnR9JyBkb2VzIG5vdCBleGlzdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwQWN0KCgpID0+IHtcclxuICAgICAgICAgIGV2ZW50Rm4oYWRhcHRlci5ub2RlVG9Ib3N0Tm9kZShub2RlKSwgbW9jayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4udGhpcyxcclxuICAgICAgICAgIC4uLmdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcih7XHJcbiAgICAgICAgICAgIHRvVHJlZTogKGluc3QpID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFscyksXHJcbiAgICAgICAgICAgIGdldE1vdW50V3JhcHBlckluc3RhbmNlOiAoKSA9PiBpbnN0YW5jZSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHdyYXBJbnZva2U6IHdyYXBBY3QsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlU2hhbGxvd1JlbmRlcmVyKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcclxuICAgIGNvbnN0IHsgc3VzcGVuc2VGYWxsYmFjayB9ID0gb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2Ygc3VzcGVuc2VGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHN1c3BlbnNlRmFsbGJhY2sgIT09ICdib29sZWFuJykge1xyXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2BvcHRpb25zLnN1c3BlbnNlRmFsbGJhY2tgIHNob3VsZCBiZSBib29sZWFuIG9yIHVuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG4gICAgbGV0IGlzRE9NID0gZmFsc2U7XHJcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XHJcblxyXG4gICAgbGV0IGxhc3RDb21wb25lbnQgPSBudWxsO1xyXG4gICAgbGV0IHdyYXBwZWRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgY29uc3Qgc2VudGluZWwgPSB7fTtcclxuXHJcbiAgICAvLyB3cmFwIG1lbW8gY29tcG9uZW50cyB3aXRoIGEgUHVyZUNvbXBvbmVudCwgb3IgYSBjbGFzcyBjb21wb25lbnQgd2l0aCBzQ1VcclxuICAgIGNvbnN0IHdyYXBQdXJlQ29tcG9uZW50ID0gKENvbXBvbmVudCwgY29tcGFyZSkgPT4ge1xyXG4gICAgICBpZiAobGFzdENvbXBvbmVudCAhPT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGVmdWwoQ29tcG9uZW50KSkge1xyXG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb25cclxuICAgICAgICAgIGlmIChjb21wYXJlKSB7XHJcbiAgICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IChuZXh0UHJvcHMpID0+ICFjb21wYXJlKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBtZW1vaXplZCA9IHNlbnRpbmVsO1xyXG4gICAgICAgICAgbGV0IHByZXZQcm9wcztcclxuICAgICAgICAgIHdyYXBwZWRDb21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gbWVtb2l6ZWQgPT09IHNlbnRpbmVsIHx8IChjb21wYXJlXHJcbiAgICAgICAgICAgICAgPyAhY29tcGFyZShwcmV2UHJvcHMsIHByb3BzKVxyXG4gICAgICAgICAgICAgIDogIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIHByb3BzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgbWVtb2l6ZWQgPSBDb21wb25lbnQoeyAuLi5Db21wb25lbnQuZGVmYXVsdFByb3BzLCAuLi5wcm9wcyB9LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCxcclxuICAgICAgICAgIENvbXBvbmVudCxcclxuICAgICAgICAgIHsgZGlzcGxheU5hbWU6IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiBDb21wb25lbnQgfSkgfSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHdyYXBwZWRDb21wb25lbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJlbmRlckVsZW1lbnQgPSAoZWxDb25maWcsIC4uLnJlc3QpID0+IHtcclxuICAgICAgY29uc3QgcmVuZGVyZWRFbCA9IHJlbmRlcmVyLnJlbmRlcihlbENvbmZpZywgLi4ucmVzdCk7XHJcblxyXG4gICAgICBpZiAocmVuZGVyZWRFbCAmJiByZW5kZXJlZEVsLnR5cGUpIHtcclxuICAgICAgICBjb25zdCBjbG9uZWRFbCA9IHRyYW5zZm9ybVN1c3BlbnNlKHJlbmRlcmVkRWwsIGVsQ29uZmlnLCB7IHN1c3BlbnNlRmFsbGJhY2sgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRJc0NoYW5nZWQgPSBjbG9uZWRFbC50eXBlICE9PSByZW5kZXJlZEVsLnR5cGU7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJc0NoYW5nZWQpIHtcclxuICAgICAgICAgIHJldHVybiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbENvbmZpZywgdHlwZTogY2xvbmVkRWwudHlwZSB9LCAuLi5yZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZW5kZXJlZEVsO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZW5kZXIoZWwsIHVubWFza2VkQ29udGV4dCwge1xyXG4gICAgICAgIHByb3ZpZGVyVmFsdWVzID0gbmV3IE1hcCgpLFxyXG4gICAgICB9ID0ge30pIHtcclxuICAgICAgICBjYWNoZWROb2RlID0gZWw7XHJcbiAgICAgICAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbC50eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaXNET00gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0UHJvdmlkZXIoZWwpKSB7XHJcbiAgICAgICAgICBwcm92aWRlclZhbHVlcy5zZXQoZWwudHlwZSwgZWwucHJvcHMudmFsdWUpO1xyXG4gICAgICAgICAgY29uc3QgTW9ja1Byb3ZpZGVyID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICAgICAgKHByb3BzKSA9PiBwcm9wcy5jaGlsZHJlbixcclxuICAgICAgICAgICAgZWwudHlwZSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJFbGVtZW50KHsgLi4uZWwsIHR5cGU6IE1vY2tQcm92aWRlciB9KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbnRleHRDb25zdW1lcihlbCkpIHtcclxuICAgICAgICAgIGNvbnN0IFByb3ZpZGVyID0gYWRhcHRlci5nZXRQcm92aWRlckZyb21Db25zdW1lcihlbC50eXBlKTtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXJWYWx1ZXMuaGFzKFByb3ZpZGVyKVxyXG4gICAgICAgICAgICA/IHByb3ZpZGVyVmFsdWVzLmdldChQcm92aWRlcilcclxuICAgICAgICAgICAgOiBnZXRQcm92aWRlckRlZmF1bHRWYWx1ZShQcm92aWRlcik7XHJcbiAgICAgICAgICBjb25zdCBNb2NrQ29uc3VtZXIgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgICAgICAocHJvcHMpID0+IHByb3BzLmNoaWxkcmVuKHZhbHVlKSxcclxuICAgICAgICAgICAgZWwudHlwZSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJFbGVtZW50KHsgLi4uZWwsIHR5cGU6IE1vY2tDb25zdW1lciB9KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlzRE9NID0gZmFsc2U7XHJcbiAgICAgICAgICBsZXQgcmVuZGVyZWRFbCA9IGVsO1xyXG4gICAgICAgICAgaWYgKGlzTGF6eShyZW5kZXJlZEVsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2BSZWFjdC5sYXp5YCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHNoYWxsb3cgcmVuZGVyaW5nLicpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlbmRlcmVkRWwgPSB0cmFuc2Zvcm1TdXNwZW5zZShyZW5kZXJlZEVsLCByZW5kZXJlZEVsLCB7IHN1c3BlbnNlRmFsbGJhY2sgfSk7XHJcbiAgICAgICAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCB9ID0gcmVuZGVyZWRFbDtcclxuXHJcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQuY29udGV4dFR5cGVzLCB1bm1hc2tlZENvbnRleHQpO1xyXG5cclxuICAgICAgICAgIGlmIChpc01lbW8oZWwudHlwZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB0eXBlOiBJbm5lckNvbXAsIGNvbXBhcmUgfSA9IGVsLnR5cGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJFbGVtZW50KFxyXG4gICAgICAgICAgICAgIHsgLi4uZWwsIHR5cGU6IHdyYXBQdXJlQ29tcG9uZW50KElubmVyQ29tcCwgY29tcGFyZSkgfSxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWlzU3RhdGVmdWwoQ29tcG9uZW50KSAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlckVsZW1lbnQoXHJcbiAgICAgICAgICAgICAgeyAuLi5yZW5kZXJlZEVsLCB0eXBlOiBDb21wb25lbnQgfSxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJFbGVtZW50KHJlbmRlcmVkRWwsIGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgcmVuZGVyZXIudW5tb3VudCgpO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXROb2RlKCkge1xyXG4gICAgICAgIGlmIChpc0RPTSkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoY2FjaGVkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJlbmRlcmVyLmdldFJlbmRlck91dHB1dCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBub2RlVHlwZTogbm9kZVR5cGVGcm9tVHlwZShjYWNoZWROb2RlLnR5cGUpLFxyXG4gICAgICAgICAgdHlwZTogY2FjaGVkTm9kZS50eXBlLFxyXG4gICAgICAgICAgcHJvcHM6IGNhY2hlZE5vZGUucHJvcHMsXHJcbiAgICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGNhY2hlZE5vZGUua2V5KSxcclxuICAgICAgICAgIHJlZjogY2FjaGVkTm9kZS5yZWYsXHJcbiAgICAgICAgICBpbnN0YW5jZTogcmVuZGVyZXIuX2luc3RhbmNlLFxyXG4gICAgICAgICAgcmVuZGVyZWQ6IEFycmF5LmlzQXJyYXkob3V0cHV0KVxyXG4gICAgICAgICAgICA/IGZsYXR0ZW4ob3V0cHV0KS5tYXAoKGVsKSA9PiBlbGVtZW50VG9UcmVlKGVsKSlcclxuICAgICAgICAgICAgOiBlbGVtZW50VG9UcmVlKG91dHB1dCksXHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcclxuICAgICAgICBzaW11bGF0ZUVycm9yKFxyXG4gICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UsXHJcbiAgICAgICAgICBjYWNoZWROb2RlLFxyXG4gICAgICAgICAgbm9kZUhpZXJhcmNoeS5jb25jYXQoY2FjaGVkTm9kZSksXHJcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxyXG4gICAgICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSxcclxuICAgICAgICAgIGNhY2hlZE5vZGUudHlwZSxcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBzaW11bGF0ZUV2ZW50KG5vZGUsIGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5vZGUucHJvcHNbcHJvcEZyb21FdmVudChldmVudCwgZXZlbnRPcHRpb25zKV07XHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGNyZWF0ZS91c2Ugc3ludGhldGljIGV2ZW50c1xyXG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGVtdWxhdGUgUmVhY3QncyBldmVudCBwcm9wYWdhdGlvblxyXG4gICAgICAgICAgICAvLyBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XHJcbiAgICAgICAgICAgIC8vIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBiYXRjaGVkVXBkYXRlcyhmbikge1xyXG4gICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgIC8vIHJldHVybiBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhmbik7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgaGllcmFyY2h5KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvcFR5cGVzKFxyXG4gICAgICAgICAgdHlwZVNwZWNzLFxyXG4gICAgICAgICAgdmFsdWVzLFxyXG4gICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICBkaXNwbGF5TmFtZU9mTm9kZShjYWNoZWROb2RlKSxcclxuICAgICAgICAgICgpID0+IGdldENvbXBvbmVudFN0YWNrKGhpZXJhcmNoeS5jb25jYXQoW2NhY2hlZE5vZGVdKSksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjcmVhdGVTdHJpbmdSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICBpZiAoaGFzKG9wdGlvbnMsICdzdXNwZW5zZUZhbGxiYWNrJykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHN1c3BlbnNlRmFsbGJhY2tgIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGluIG9wdGlvbnMgb2Ygc3RyaW5nIHJlbmRlcmVyJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0ICYmIChlbC50eXBlLmNvbnRleHRUeXBlcyB8fCBvcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzKSkge1xyXG4gICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XHJcbiAgICAgICAgICAgIC4uLihlbC50eXBlLmNvbnRleHRUeXBlcyB8fCB7fSksXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgY29uc3QgQ29udGV4dFdyYXBwZXIgPSBjcmVhdGVSZW5kZXJXcmFwcGVyKGVsLCBjb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcyk7XHJcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0V3JhcHBlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoZWwpO1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFByb3ZpZGVkIGEgYmFnIG9mIG9wdGlvbnMsIHJldHVybiBhbiBgRW56eW1lUmVuZGVyZXJgLiBTb21lIG9wdGlvbnMgY2FuIGJlIGltcGxlbWVudGF0aW9uXHJcbiAgLy8gc3BlY2lmaWMsIGxpa2UgYGF0dGFjaGAgZXRjLiBmb3IgUmVhY3QsIGJ1dCBub3QgcGFydCBvZiB0aGlzIGludGVyZmFjZSBleHBsaWNpdGx5LlxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXHJcbiAgY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgc3dpdGNoIChvcHRpb25zLm1vZGUpIHtcclxuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLk1PVU5UOiByZXR1cm4gdGhpcy5jcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpO1xyXG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU0hBTExPVzogcmV0dXJuIHRoaXMuY3JlYXRlU2hhbGxvd1JlbmRlcmVyKG9wdGlvbnMpO1xyXG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU1RSSU5HOiByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmdSZW5kZXJlcihvcHRpb25zKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuenltZSBJbnRlcm5hbCBFcnJvcjogVW5yZWNvZ25pemVkIG1vZGU6ICR7b3B0aW9ucy5tb2RlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd3JhcChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gd3JhcChlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8vIGNvbnZlcnRzIGFuIFJTVE5vZGUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSlNYIFByYWdtYSBFbGVtZW50LiBUaGlzIHdpbGwgYmUgbmVlZGVkXHJcbiAgLy8gaW4gb3JkZXIgdG8gaW1wbGVtZW50IHRoZSBgV3JhcHBlci5tb3VudCgpYCBhbmQgYFdyYXBwZXIuc2hhbGxvdygpYCBtZXRob2RzLCBidXQgc2hvdWxkXHJcbiAgLy8gYmUgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZCBmb3IgcGVvcGxlIHRvIGltcGxlbWVudC5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gIG5vZGVUb0VsZW1lbnQobm9kZSkge1xyXG4gICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCB7IHR5cGUgfSA9IG5vZGU7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh1bm1lbW9UeXBlKHR5cGUpLCBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpKTtcclxuICB9XHJcblxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXHJcbiAgbWF0Y2hlc0VsZW1lbnRUeXBlKG5vZGUsIG1hdGNoaW5nVHlwZSkge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlIH0gPSBub2RlO1xyXG4gICAgcmV0dXJuIHVubWVtb1R5cGUodHlwZSkgPT09IHVubWVtb1R5cGUobWF0Y2hpbmdUeXBlKTtcclxuICB9XHJcblxyXG4gIGVsZW1lbnRUb05vZGUoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBub2RlVG9Ib3N0Tm9kZShub2RlLCBzdXBwb3J0c0FycmF5ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IG5vZGVzID0gbm9kZVRvSG9zdE5vZGUobm9kZSk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykgJiYgIXN1cHBvcnRzQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG4gIH1cclxuXHJcbiAgZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xyXG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IHsgdHlwZSwgJCR0eXBlb2YgfSA9IG5vZGU7XHJcblxyXG4gICAgY29uc3Qgbm9kZVR5cGUgPSB0eXBlIHx8ICQkdHlwZW9mO1xyXG5cclxuICAgIC8vIG5ld2VyIG5vZGUgdHlwZXMgbWF5IGJlIHVuZGVmaW5lZCwgc28gb25seSB0ZXN0IGlmIHRoZSBub2RlVHlwZSBleGlzdHNcclxuICAgIGlmIChub2RlVHlwZSkge1xyXG4gICAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBDb25jdXJyZW50TW9kZSB8fCBOYU46IHJldHVybiAnQ29uY3VycmVudE1vZGUnO1xyXG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcclxuICAgICAgICBjYXNlIFN0cmljdE1vZGUgfHwgTmFOOiByZXR1cm4gJ1N0cmljdE1vZGUnO1xyXG4gICAgICAgIGNhc2UgUHJvZmlsZXIgfHwgTmFOOiByZXR1cm4gJ1Byb2ZpbGVyJztcclxuICAgICAgICBjYXNlIFBvcnRhbCB8fCBOYU46IHJldHVybiAnUG9ydGFsJztcclxuICAgICAgICBjYXNlIFN1c3BlbnNlIHx8IE5hTjogcmV0dXJuICdTdXNwZW5zZSc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcclxuXHJcbiAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xyXG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lciB8fCBOYU46IHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcclxuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXIgfHwgTmFOOiByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XHJcbiAgICAgIGNhc2UgTWVtbyB8fCBOYU46IHtcclxuICAgICAgICBjb25zdCBub2RlTmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZU5hbWUgPT09ICdzdHJpbmcnID8gbm9kZU5hbWUgOiBgTWVtbygke2Rpc3BsYXlOYW1lT2ZOb2RlKHR5cGUpfSlgO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgRm9yd2FyZFJlZiB8fCBOYU46IHtcclxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSh7IHR5cGU6IHR5cGUucmVuZGVyIH0pO1xyXG4gICAgICAgIHJldHVybiBuYW1lID8gYEZvcndhcmRSZWYoJHtuYW1lfSlgIDogJ0ZvcndhcmRSZWYnO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgTGF6eSB8fCBOYU46IHtcclxuICAgICAgICByZXR1cm4gJ2xhenknO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBkaXNwbGF5TmFtZU9mTm9kZShub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gISFvYmplY3QgJiYgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCk7XHJcbiAgfVxyXG5cclxuICBpc0ZyYWdtZW50KGZyYWdtZW50KSB7XHJcbiAgICByZXR1cm4gdHlwZU9mTm9kZShmcmFnbWVudCkgPT09IEZyYWdtZW50O1xyXG4gIH1cclxuXHJcbiAgaXNDdXN0b21Db21wb25lbnQodHlwZSkge1xyXG4gICAgY29uc3QgZmFrZUVsZW1lbnQgPSBtYWtlRmFrZUVsZW1lbnQodHlwZSk7XHJcbiAgICByZXR1cm4gISF0eXBlICYmIChcclxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbidcclxuICAgICAgfHwgaXNGb3J3YXJkUmVmKGZha2VFbGVtZW50KVxyXG4gICAgICB8fCBpc0NvbnRleHRQcm92aWRlcihmYWtlRWxlbWVudClcclxuICAgICAgfHwgaXNDb250ZXh0Q29uc3VtZXIoZmFrZUVsZW1lbnQpXHJcbiAgICAgIHx8IGlzU3VzcGVuc2UoZmFrZUVsZW1lbnQpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaXNDb250ZXh0Q29uc3VtZXIodHlwZSkge1xyXG4gICAgcmV0dXJuICEhdHlwZSAmJiBpc0NvbnRleHRDb25zdW1lcihtYWtlRmFrZUVsZW1lbnQodHlwZSkpO1xyXG4gIH1cclxuXHJcbiAgaXNDdXN0b21Db21wb25lbnRFbGVtZW50KGluc3QpIHtcclxuICAgIGlmICghaW5zdCB8fCAhdGhpcy5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5pc0N1c3RvbUNvbXBvbmVudChpbnN0LnR5cGUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpIHtcclxuICAgIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlciBvbiBhIENvbnN1bWVyIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cclxuICAgIGlmIChDb25zdW1lcikge1xyXG4gICAgICBsZXQgUHJvdmlkZXI7XHJcbiAgICAgIGlmIChDb25zdW1lci5fY29udGV4dCkgeyAvLyBjaGVjayB0aGlzIGZpcnN0LCB0byBhdm9pZCBhIGRlcHJlY2F0aW9uIHdhcm5pbmdcclxuICAgICAgICAoeyBQcm92aWRlciB9ID0gQ29uc3VtZXIuX2NvbnRleHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKENvbnN1bWVyLlByb3ZpZGVyKSB7XHJcbiAgICAgICAgKHsgUHJvdmlkZXIgfSA9IENvbnN1bWVyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoUHJvdmlkZXIpIHtcclxuICAgICAgICByZXR1cm4gUHJvdmlkZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlciBmcm9tIENvbnN1bWVyJyk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVFbGVtZW50KC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBSb290RmluZGVyLFxyXG4gICAgICBub2RlOiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KFJlYWN0LmNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFaWdodGVlbkFkYXB0ZXI7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQXFCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFzQkE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFJQSxTQUFTLEdBQUcsSUFBaEI7O0FBRUEsU0FBU0Msb0JBQVQsQ0FBOEJDLGVBQTlCLEVBQStDO0VBQzdDLElBQU1DLEtBQUssR0FBRyxFQUFkO0VBQ0EsSUFBSUMsSUFBSSxHQUFHRixlQUFYOztFQUNBLE9BQU9FLElBQUksSUFBSSxJQUFmLEVBQXFCO0lBQ25CRCxLQUFLLENBQUNFLElBQU4sQ0FBV0QsSUFBWDtJQUNBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ0UsT0FBWjtFQUNEOztFQUNELE9BQU9ILEtBQVA7QUFDRDs7QUFFRCxTQUFTSSxPQUFULENBQWlCQyxHQUFqQixFQUFzQjtFQUNwQixJQUFNQyxNQUFNLEdBQUcsRUFBZjtFQUNBLElBQU1DLEtBQUssR0FBRyxDQUFDO0lBQUVDLENBQUMsRUFBRSxDQUFMO0lBQVFSLEtBQUssRUFBRUs7RUFBZixDQUFELENBQWQ7O0VBQ0EsT0FBT0UsS0FBSyxDQUFDRSxNQUFiLEVBQXFCO0lBQ25CLElBQU1DLENBQUMsR0FBR0gsS0FBSyxDQUFDSSxHQUFOLEVBQVY7O0lBQ0EsT0FBT0QsQ0FBQyxDQUFDRixDQUFGLEdBQU1FLENBQUMsQ0FBQ1YsS0FBRixDQUFRUyxNQUFyQixFQUE2QjtNQUMzQixJQUFNRyxFQUFFLEdBQUdGLENBQUMsQ0FBQ1YsS0FBRixDQUFRVSxDQUFDLENBQUNGLENBQVYsQ0FBWDtNQUNBRSxDQUFDLENBQUNGLENBQUYsSUFBTyxDQUFQOztNQUNB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
//# sourceMappingURL=ReactEighteenAdapter.js.map