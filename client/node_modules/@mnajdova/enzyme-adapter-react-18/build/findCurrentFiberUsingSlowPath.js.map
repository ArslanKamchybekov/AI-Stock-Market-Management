{"version":3,"file":"findCurrentFiberUsingSlowPath.js","names":["findCurrentFiberUsingSlowPath","fiber","alternate","a","b","parentA","parentB","child","sibling","Error","didFindChild","stateNode","current","module","exports"],"sources":["../src/findCurrentFiberUsingSlowPath.js"],"sourcesContent":["// Extracted from https://github.com/facebook/react/blob/7bdf93b17a35a5d8fcf0ceae0bf48ed5e6b16688/src/renderers/shared/fiber/ReactFiberTreeReflection.js#L104-L228\r\nfunction findCurrentFiberUsingSlowPath(fiber) {\r\n  const { alternate } = fiber;\r\n  if (!alternate) {\r\n    return fiber;\r\n  }\r\n  // If we have two possible branches, we'll walk backwards up to the root\r\n  // to see what path the root points to. On the way we may hit one of the\r\n  // special cases and we'll deal with them.\r\n  let a = fiber;\r\n  let b = alternate;\r\n  while (true) { // eslint-disable-line\r\n    const parentA = a.return;\r\n    const parentB = parentA ? parentA.alternate : null;\r\n    if (!parentA || !parentB) {\r\n      // We're at the root.\r\n      break;\r\n    }\r\n\r\n    // If both copies of the parent fiber point to the same child, we can\r\n    // assume that the child is current. This happens when we bailout on low\r\n    // priority: the bailed out fiber's child reuses the current child.\r\n    if (parentA.child === parentB.child) {\r\n      let { child } = parentA;\r\n      while (child) {\r\n        if (child === a) {\r\n          // We've determined that A is the current branch.\r\n          return fiber;\r\n        }\r\n        if (child === b) {\r\n          // We've determined that B is the current branch.\r\n          return alternate;\r\n        }\r\n        child = child.sibling;\r\n      }\r\n      // We should never have an alternate for any mounting node. So the only\r\n      // way this could possibly happen is if this was unmounted, if at all.\r\n      throw new Error('Unable to find node on an unmounted component.');\r\n    }\r\n\r\n    if (a.return !== b.return) {\r\n      // The return pointer of A and the return pointer of B point to different\r\n      // fibers. We assume that return pointers never criss-cross, so A must\r\n      // belong to the child set of A.return, and B must belong to the child\r\n      // set of B.return.\r\n      a = parentA;\r\n      b = parentB;\r\n    } else {\r\n      // The return pointers point to the same fiber. We'll have to use the\r\n      // default, slow path: scan the child sets of each parent alternate to see\r\n      // which child belongs to which set.\r\n      //\r\n      // Search parent A's child set\r\n      let didFindChild = false;\r\n      let { child } = parentA;\r\n      while (child) {\r\n        if (child === a) {\r\n          didFindChild = true;\r\n          a = parentA;\r\n          b = parentB;\r\n          break;\r\n        }\r\n        if (child === b) {\r\n          didFindChild = true;\r\n          b = parentA;\r\n          a = parentB;\r\n          break;\r\n        }\r\n        child = child.sibling;\r\n      }\r\n      if (!didFindChild) {\r\n        // Search parent B's child set\r\n        ({ child } = parentB);\r\n        while (child) {\r\n          if (child === a) {\r\n            didFindChild = true;\r\n            a = parentB;\r\n            b = parentA;\r\n            break;\r\n          }\r\n          if (child === b) {\r\n            didFindChild = true;\r\n            b = parentB;\r\n            a = parentA;\r\n            break;\r\n          }\r\n          child = child.sibling;\r\n        }\r\n        if (!didFindChild) {\r\n          throw new Error('Child was not found in either parent set. This indicates a bug '\r\n            + 'in React related to the return pointer. Please file an issue.');\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (a.stateNode.current === a) {\r\n    // We've determined that A is the current branch.\r\n    return fiber;\r\n  }\r\n  // Otherwise B has to be current branch.\r\n  return alternate;\r\n}\r\n\r\nmodule.exports = findCurrentFiberUsingSlowPath;\r\n"],"mappings":";;AAAA;AACA,SAASA,6BAAT,CAAuCC,KAAvC,EAA8C;EAC5C,IAAQC,SAAR,GAAsBD,KAAtB,CAAQC,SAAR;;EACA,IAAI,CAACA,SAAL,EAAgB;IACd,OAAOD,KAAP;EACD,CAJ2C,CAK5C;EACA;EACA;;;EACA,IAAIE,CAAC,GAAGF,KAAR;EACA,IAAIG,CAAC,GAAGF,SAAR;;EACA,OAAO,IAAP,EAAa;IAAE;IACb,IAAMG,OAAO,GAAGF,CAAC,UAAjB;IACA,IAAMG,OAAO,GAAGD,OAAO,GAAGA,OAAO,CAACH,SAAX,GAAuB,IAA9C;;IACA,IAAI,CAACG,OAAD,IAAY,CAACC,OAAjB,EAA0B;MACxB;MACA;IACD,CANU,CAQX;IACA;IACA;;;IACA,IAAID,OAAO,CAACE,KAAR,KAAkBD,OAAO,CAACC,KAA9B,EAAqC;MACnC,IAAMA,KAAN,GAAgBF,OAAhB,CAAME,KAAN;;MACA,OAAOA,KAAP,EAAc;QACZ,IAAIA,KAAK,KAAKJ,CAAd,EAAiB;UACf;UACA,OAAOF,KAAP;QACD;;QACD,IAAIM,KAAK,KAAKH,CAAd,EAAiB;UACf;UACA,OAAOF,SAAP;QACD;;QACDK,KAAK,GAAGA,KAAK,CAACC,OAAd;MACD,CAZkC,CAanC;MACA;;;MACA,MAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;IACD;;IAED,IAAIN,CAAC,UAAD,KAAaC,CAAC,UAAlB,EAA2B;MACzB;MACA;MACA;MACA;MACAD,CAAC,GAAGE,OAAJ;MACAD,CAAC,GAAGE,OAAJ;IACD,CAPD,MAOO;MACL;MACA;MACA;MACA;MACA;MACA,IAAII,YAAY,GAAG,KAAnB;MACA,IAAMH,MAAN,GAAgBF,OAAhB,CAAME,KAAN;;MACA,OAAOA,MAAP,EAAc;QACZ,IAAIA,MAAK,KAAKJ,CAAd,EAAiB;UACfO,YAAY,GAAG,IAAf;UACAP,CAAC,GAAGE,OAAJ;UACAD,CAAC,GAAGE,OAAJ;UACA;QACD;;QACD,IAAIC,MAAK,KAAKH,CAAd,EAAiB;UACfM,YAAY,GAAG,IAAf;UACAN,CAAC,GAAGC,OAAJ;UACAF,CAAC,GAAGG,OAAJ;UACA;QACD;;QACDC,MAAK,GAAGA,MAAK,CAACC,OAAd;MACD;;MACD,IAAI,CAACE,YAAL,EAAmB;QACjB;QACGH,MAFc,GAEJD,OAFI,CAEdC,KAFc;;QAGjB,OAAOA,MAAP,EAAc;UACZ,IAAIA,MAAK,KAAKJ,CAAd,EAAiB;YACfO,YAAY,GAAG,IAAf;YACAP,CAAC,GAAGG,OAAJ;YACAF,CAAC,GAAGC,OAAJ;YACA;UACD;;UACD,IAAIE,MAAK,KAAKH,CAAd,EAAiB;YACfM,YAAY,GAAG,IAAf;YACAN,CAAC,GAAGE,OAAJ;YACAH,CAAC,GAAGE,OAAJ;YACA;UACD;;UACDE,MAAK,GAAGA,MAAK,CAACC,OAAd;QACD;;QACD,IAAI,CAACE,YAAL,EAAmB;UACjB,MAAM,IAAID,KAAJ,CAAU,oEACZ,+DADE,CAAN;QAED;MACF;IACF;EACF;;EACD,IAAIN,CAAC,CAACQ,SAAF,CAAYC,OAAZ,KAAwBT,CAA5B,EAA+B;IAC7B;IACA,OAAOF,KAAP;EACD,CAjG2C,CAkG5C;;;EACA,OAAOC,SAAP;AACD;;AAEDW,MAAM,CAACC,OAAP,GAAiBd,6BAAjB"}